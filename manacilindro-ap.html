<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Cilindro de Sílabas 3D - Letras Rotadas</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body { margin: 0; overflow: hidden; background-color: #f0f4f8; font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; }
        #ui-container {
            position: absolute;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            text-align: center;
            pointer-events: none;
            width: 100%;
        }
        .instruction-card {
            background: rgba(255, 255, 255, 0.9);
            padding: 15px 25px;
            border-radius: 15px;
            box-shadow: 0 4px 15px rgba(0,0,0,0.1);
            display: inline-block;
            pointer-events: auto;
        }
        canvas { display: block; }
    </style>
</head>
<body>

    <div id="ui-container">
        <div class="instruction-card border-b-4 border-pink-400">
            <h1 class="text-xl font-bold text-gray-800">Cilindro de Sílabas</h1>
            <p class="text-sm text-gray-600 mt-1">Gira el cilindro rosa para formar palabras</p>
        </div>
    </div>

    <script>
        let scene, camera, renderer, axle, pinkGroup, whiteCylinder;
        let isDragging = false;
        let previousMouseY = 0;
        let targetRotation = 0;
        let currentRotation = 0;

        // Letras en minúsculas y blancas
        const letters = ['c', 'g', 'n', 'm', 't'];
        const segmentAngle = (Math.PI * 2) / letters.length;

        function init() {
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0xf1f5f9);

            camera = new THREE.PerspectiveCamera(40, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 1, 7);
            camera.lookAt(0, 0, 0);

            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            document.body.appendChild(renderer.domElement);

            const ambientLight = new THREE.AmbientLight(0xffffff, 0.7);
            scene.add(ambientLight);

            const pointLight = new THREE.PointLight(0xffffff, 0.8);
            pointLight.position.set(5, 5, 5);
            scene.add(pointLight);

            // Eje horizontal
            const axleGeom = new THREE.CylinderGeometry(0.12, 0.12, 10, 32);
            const axleMat = new THREE.MeshStandardMaterial({ color: 0x94a3b8, metalness: 0.9, roughness: 0.1 });
            axle = new THREE.Mesh(axleGeom, axleMat);
            axle.rotation.z = Math.PI / 2;
            scene.add(axle);

            // PARTE ROSA
            pinkGroup = new THREE.Group();
            const cylinderGeom = new THREE.CylinderGeometry(1.6, 1.6, 2.8, 64);
            const pinkMat = new THREE.MeshStandardMaterial({ color: 0xff8fa3, roughness: 0.3 });
            const pinkBaseMesh = new THREE.Mesh(cylinderGeom, pinkMat);
            pinkBaseMesh.rotation.z = Math.PI / 2;
            pinkGroup.add(pinkBaseMesh);

            letters.forEach((letter, i) => {
                const canvas = document.createElement('canvas');
                canvas.width = 512;
                canvas.height = 512;
                const ctx = canvas.getContext('2d');
                
                ctx.fillStyle = 'white'; 
                ctx.font = 'bold 320px Arial';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText(letter, 256, 256);

                const texture = new THREE.CanvasTexture(canvas);
                
                // Rotar la letra 90 grados a la derecha (sentido horario)
                texture.center.set(0.5, 0.5);
                texture.rotation = -Math.PI / 2; 

                const letterMat = new THREE.MeshBasicMaterial({ 
                    map: texture, 
                    transparent: true, 
                    side: THREE.DoubleSide 
                });

                const letterGeom = new THREE.CylinderGeometry(1.62, 1.62, 1.4, 32, 1, true, -0.4, 0.8);
                const letterMesh = new THREE.Mesh(letterGeom, letterMat);

                letterMesh.rotation.z = Math.PI / 2;
                
                const angle = i * segmentAngle;
                const pivot = new THREE.Group();
                pivot.rotation.x = angle;
                pivot.add(letterMesh);
                
                pinkGroup.add(pivot);
            });

            pinkGroup.position.x = -1.5;
            scene.add(pinkGroup);

            // PARTE BLANCA (Fija)
            const whiteGroup = new THREE.Group();
            const whiteMat = new THREE.MeshStandardMaterial({ color: 0xffffff, roughness: 0.5 });
            const whiteBaseMesh = new THREE.Mesh(cylinderGeom, whiteMat);
            whiteBaseMesh.rotation.z = Math.PI / 2;
            whiteGroup.add(whiteBaseMesh);

            const apCanvas = document.createElement('canvas');
            apCanvas.width = 512;
            apCanvas.height = 512;
            const apCtx = apCanvas.getContext('2d');
            apCtx.fillStyle = '#1e293b';
            apCtx.font = 'bold 280px Arial';
            apCtx.textAlign = 'center';
            apCtx.textBaseline = 'middle';
            apCtx.fillText('ap', 256, 256);

            const apTexture = new THREE.CanvasTexture(apCanvas);
            
            // Rotar "ap" 90 grados a la derecha (sentido horario)
            apTexture.center.set(0.5, 0.5);
            apTexture.rotation = -Math.PI / 2;

            const apMat = new THREE.MeshBasicMaterial({ map: apTexture, transparent: true });
            
            const apGeom = new THREE.CylinderGeometry(1.62, 1.62, 1.8, 32, 1, true, -0.6, 1.2);
            const apMesh = new THREE.Mesh(apGeom, apMat);
            apMesh.rotation.z = Math.PI / 2;
            
            whiteGroup.add(apMesh);
            whiteGroup.position.x = 1.5;
            scene.add(whiteGroup);

            // Interacción
            window.addEventListener('resize', onWindowResize);
            document.addEventListener('keydown', onKeyDown);
            
            renderer.domElement.addEventListener('mousedown', (e) => { isDragging = true; previousMouseY = e.clientY; });
            window.addEventListener('mouseup', () => { isDragging = false; snapToLetter(); });
            window.addEventListener('mousemove', (e) => {
                if (!isDragging) return;
                targetRotation += (e.clientY - previousMouseY) * 0.015;
                previousMouseY = e.clientY;
            });

            renderer.domElement.addEventListener('touchstart', (e) => {
                isDragging = true;
                previousMouseY = e.touches[0].clientY;
            }, { passive: false });
            window.addEventListener('touchend', () => { isDragging = false; snapToLetter(); });
            window.addEventListener('touchmove', (e) => {
                if (!isDragging) return;
                targetRotation += (e.touches[0].clientY - previousMouseY) * 0.015;
                previousMouseY = e.touches[0].clientY;
                e.preventDefault();
            }, { passive: false });

            animate();
        }

        function onKeyDown(e) {
            if (e.key === 'ArrowUp' || e.key === 'ArrowLeft') targetRotation -= segmentAngle;
            if (e.key === 'ArrowDown' || e.key === 'ArrowRight') targetRotation += segmentAngle;
            snapToLetter();
        }

        function snapToLetter() {
            const index = Math.round(targetRotation / segmentAngle);
            targetRotation = index * segmentAngle;
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function animate() {
            requestAnimationFrame(animate);
            currentRotation += (targetRotation - currentRotation) * 0.15;
            pinkGroup.rotation.x = currentRotation;
            renderer.render(scene, camera);
        }

        window.onload = init;
    </script>
</body>
</html>
